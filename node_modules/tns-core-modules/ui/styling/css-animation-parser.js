<<<<<<< HEAD
Object.defineProperty(exports, "__esModule", { value: true });
var properties_1 = require("../core/properties");
var keyframe_animation_1 = require("../animation/keyframe-animation");
var converters_1 = require("../styling/converters");
var style_properties_1 = require("../styling/style-properties");
var ANIMATION_PROPERTY_HANDLERS = Object.freeze({
    "animation-name": function (info, value) { return info.name = value; },
    "animation-duration": function (info, value) { return info.duration = converters_1.timeConverter(value); },
    "animation-delay": function (info, value) { return info.delay = converters_1.timeConverter(value); },
    "animation-timing-function": function (info, value) { return info.curve = converters_1.animationTimingFunctionConverter(value); },
    "animation-iteration-count": function (info, value) { return info.iterations = value === "infinite" ? Number.MAX_VALUE : parseFloat(value); },
    "animation-direction": function (info, value) { return info.isReverse = value === "reverse"; },
    "animation-fill-mode": function (info, value) { return info.isForwards = value === "forwards"; }
});
=======
var keyframeAnimationModule = require("ui/animation/keyframe-animation");
var converters = require("../styling/converters");
var types = require("utils/types");
var colorModule = require("color");
var styleProperty = require("ui/styling/style-property");
var animationProperties = {
    "animation-name": function (info, declaration) { return info.name = declaration.value; },
    "animation-duration": function (info, declaration) { return info.duration = converters.timeConverter(declaration.value); },
    "animation-delay": function (info, declaration) { return info.delay = converters.timeConverter(declaration.value); },
    "animation-timing-function": function (info, declaration) { return info.curve = converters.animationTimingFunctionConverter(declaration.value); },
    "animation-iteration-count": function (info, declaration) { return declaration.value === "infinite" ? info.iterations = Number.MAX_VALUE : info.iterations = converters.numberConverter(declaration.value); },
    "animation-direction": function (info, declaration) { return info.isReverse = declaration.value === "reverse"; },
    "animation-fill-mode": function (info, declaration) { return info.isForwards = declaration.value === "forwards"; }
};
>>>>>>> parent of 0d3ab98... node modules after tis-core-modules 3.0.0
var CssAnimationParser = (function () {
    function CssAnimationParser() {
    }
    CssAnimationParser.keyframeAnimationsFromCSSDeclarations = function (declarations) {
        if (declarations === null || declarations === undefined) {
            return undefined;
        }
<<<<<<< HEAD
        var animations = new Array();
        var animationInfo = undefined;
        declarations.forEach(function (_a) {
            var property = _a.property, value = _a.value;
            if (property === "animation") {
                keyframeAnimationsFromCSSProperty(value, animations);
=======
        for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
            var declaration = declarations_1[_i];
            if (declaration.property === "animation") {
                CssAnimationParser.keyframeAnimationsFromCSSProperty(declaration.value, animations);
>>>>>>> parent of 0d3ab98... node modules after tis-core-modules 3.0.0
            }
            else {
                var propertyHandler = ANIMATION_PROPERTY_HANDLERS[property];
                if (propertyHandler) {
                    if (animationInfo === undefined) {
                        animationInfo = new keyframeAnimationModule.KeyframeAnimationInfo();
                        animations.push(animationInfo);
                    }
                    propertyHandler(animationInfo, value);
                }
            }
        });
        return animations.length === 0 ? undefined : animations;
    };
    CssAnimationParser.keyframesArrayFromCSS = function (keyframes) {
        var parsedKeyframes = new Array();
<<<<<<< HEAD
        for (var _i = 0, keyframes_1 = keyframes; _i < keyframes_1.length; _i++) {
            var keyframe = keyframes_1[_i];
            var declarations = parseKeyframeDeclarations(keyframe.declarations);
            for (var _a = 0, _b = keyframe.values; _a < _b.length; _a++) {
                var time_1 = _b[_a];
=======
        for (var _i = 0, _a = cssKeyframes.keyframes; _i < _a.length; _i++) {
            var keyframe = _a[_i];
            var declarations = CssAnimationParser.parseKeyframeDeclarations(keyframe);
            for (var _b = 0, _c = keyframe.values; _b < _c.length; _b++) {
                var time_1 = _c[_b];
>>>>>>> parent of 0d3ab98... node modules after tis-core-modules 3.0.0
                if (time_1 === "from") {
                    time_1 = 0;
                }
                else if (time_1 === "to") {
                    time_1 = 1;
                }
                else {
                    time_1 = parseFloat(time_1) / 100;
                    if (time_1 < 0) {
                        time_1 = 0;
                    }
                    if (time_1 > 100) {
                        time_1 = 100;
                    }
                }
                var current = parsedKeyframes[time_1];
                if (current === undefined) {
                    current = {};
                    current.duration = time_1;
                    parsedKeyframes[time_1] = current;
                }
                for (var _c = 0, _d = keyframe.declarations; _c < _d.length; _c++) {
                    var declaration = _d[_c];
                    if (declaration.property === "animation-timing-function") {
                        current.curve = converters.animationTimingFunctionConverter(declaration.value);
                    }
                }
                current.declarations = declarations;
            }
        }
        var array = new Array();
        for (var parsedKeyframe in parsedKeyframes) {
            array.push(parsedKeyframes[parsedKeyframe]);
        }
        array.sort(function (a, b) { return a.duration - b.duration; });
        return array;
    };
    CssAnimationParser.keyframeAnimationsFromCSSProperty = function (value, animations) {
        if (types.isString(value)) {
            var values = value.split(/[,]+/);
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var parsedValue = values_1[_i];
                var animationInfo = new keyframeAnimationModule.KeyframeAnimationInfo();
                var arr = parsedValue.trim().split(/[ ]+/);
                if (arr.length > 0) {
                    animationInfo.name = arr[0];
                }
                if (arr.length > 1) {
                    animationInfo.duration = converters.timeConverter(arr[1]);
                }
                if (arr.length > 2) {
                    animationInfo.curve = converters.animationTimingFunctionConverter(arr[2]);
                }
                if (arr.length > 3) {
                    animationInfo.delay = converters.timeConverter(arr[3]);
                }
                if (arr.length > 4) {
                    animationInfo.iterations = parseInt(arr[4]);
                }
                if (arr.length > 5) {
                    animationInfo.isReverse = arr[4] === "reverse";
                }
                if (arr.length > 6) {
                    animationInfo.isForwards = arr[5] === "forwards";
                }
                if (arr.length > 7) {
                    throw new Error("Invalid value for animation: " + value);
                }
                animations.push(animationInfo);
            }
        }
<<<<<<< HEAD
    }
}
function parseKeyframeDeclarations(unparsedKeyframeDeclarations) {
    var declarations = unparsedKeyframeDeclarations
        .reduce(function (declarations, _a) {
        var unparsedProperty = _a.property, unparsedValue = _a.value;
        var property = properties_1.CssAnimationProperty._getByCssName(unparsedProperty);
        if (typeof unparsedProperty === "string" && property && property._valueConverter) {
            declarations[property.name] = property._valueConverter(unparsedValue);
        }
        else if (typeof unparsedValue === "string" && unparsedProperty === "transform") {
            var transformations = style_properties_1.transformConverter(unparsedValue);
            Object.assign(declarations, transformations);
        }
        return declarations;
    }, {});
    return Object.keys(declarations).map(function (property) { return ({ property: property, value: declarations[property] }); });
}
exports.parseKeyframeDeclarations = parseKeyframeDeclarations;
=======
    };
    CssAnimationParser.parseKeyframeDeclarations = function (keyframe) {
        var declarations = {};
        var transforms = { scale: undefined, translate: undefined };
        for (var _i = 0, _a = keyframe.declarations; _i < _a.length; _i++) {
            var declaration = _a[_i];
            var property = styleProperty.getPropertyByCssName(declaration.property);
            if (property) {
                var val = declaration.value;
                if (property.name === "opacity") {
                    val = parseFloat(val);
                }
                else if (property.name === "backgroundColor") {
                    val = new colorModule.Color(val);
                }
                declarations[property.name] = val;
            }
            else {
                var pairs = styleProperty.getShorthandPairs(declaration.property, declaration.value);
                if (pairs) {
                    for (var j = 0; j < pairs.length; j++) {
                        var pair = pairs[j];
                        if (!this.preprocessAnimationValues(pair, transforms)) {
                            declarations[pair.property.name] = pair.value;
                        }
                    }
                }
            }
        }
        if (transforms.scale !== undefined) {
            declarations["scale"] = transforms.scale;
        }
        if (transforms.translate !== undefined) {
            declarations["translate"] = transforms.translate;
        }
        var array = new Array();
        for (var declaration in declarations) {
            var keyframeDeclaration = {};
            keyframeDeclaration.property = declaration;
            keyframeDeclaration.value = declarations[declaration];
            array.push(keyframeDeclaration);
        }
        return array;
    };
    CssAnimationParser.preprocessAnimationValues = function (pair, transforms) {
        if (pair.property.name === "scaleX") {
            if (transforms.scale === undefined) {
                transforms.scale = { x: 1, y: 1 };
            }
            transforms.scale.x = pair.value;
            return true;
        }
        if (pair.property.name === "scaleY") {
            if (transforms.scale === undefined) {
                transforms.scale = { x: 1, y: 1 };
            }
            transforms.scale.y = pair.value;
            return true;
        }
        if (pair.property.name === "translateX") {
            if (transforms.translate === undefined) {
                transforms.translate = { x: 0, y: 0 };
            }
            transforms.translate.x = pair.value;
            return true;
        }
        if (pair.property.name === "translateY") {
            if (transforms.translate === undefined) {
                transforms.translate = { x: 0, y: 0 };
            }
            transforms.translate.y = pair.value;
            return true;
        }
        return false;
    };
    return CssAnimationParser;
}());
exports.CssAnimationParser = CssAnimationParser;
>>>>>>> parent of 0d3ab98... node modules after tis-core-modules 3.0.0
//# sourceMappingURL=css-animation-parser.js.map